package repository

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"backend/pkg/core"
	"backend/pkg/database/models"
	"backend/pkg/types"

	"github.com/google/uuid"
	"github.com/pgvector/pgvector-go"
	"gorm.io/datatypes"
	"gorm.io/gorm"
)

// InsightTopicRepository provides data access for insight topics
type InsightTopicRepository struct {
	db *gorm.DB
}

// NewInsightTopicRepository creates a new InsightTopicRepository
func NewInsightTopicRepository(db *gorm.DB) *InsightTopicRepository {
	return &InsightTopicRepository{db: db}
}

// insightTopicModelToType converts a database model to types
func insightTopicModelToType(m *models.InsightTopic) *types.InsightTopic {
	var keywords []string
	if m.Keywords != nil {
		_ = json.Unmarshal(m.Keywords, &keywords)
	}

	var embedding []float32
	if m.Embedding.Slice() != nil {
		embedding = m.Embedding.Slice()
	}

	return &types.InsightTopic{
		ID:              m.ID,
		OrganizationID:  m.OrganizationID,
		Name:            m.Name,
		Description:     m.Description,
		Keywords:        keywords,
		Embedding:       embedding,
		IsAutoGenerated: m.IsAutoGenerated,
		ContentCount:    m.ContentCount,
		LastInsightAt:   m.LastInsightAt,
		Color:           m.Color,
		Icon:            m.Icon,
		CreatedAt:       m.CreatedAt,
		UpdatedAt:       m.UpdatedAt,
	}
}

// insightTopicTypeToModel converts a types type to database model
func insightTopicTypeToModel(t *types.InsightTopic) *models.InsightTopic {
	var keywords datatypes.JSON
	if t.Keywords != nil {
		data, _ := json.Marshal(t.Keywords)
		keywords = datatypes.JSON(data)
	}

	var embedding pgvector.Vector
	if len(t.Embedding) > 0 {
		embedding = pgvector.NewVector(t.Embedding)
	}

	return &models.InsightTopic{
		ID:              t.ID,
		OrganizationID:  t.OrganizationID,
		Name:            t.Name,
		Description:     t.Description,
		Keywords:        keywords,
		Embedding:       embedding,
		IsAutoGenerated: t.IsAutoGenerated,
		ContentCount:    t.ContentCount,
		LastInsightAt:   t.LastInsightAt,
		Color:           t.Color,
		Icon:            t.Icon,
		CreatedAt:       t.CreatedAt,
		UpdatedAt:       t.UpdatedAt,
	}
}

// FindByID retrieves an insight topic by its ID
func (r *InsightTopicRepository) FindByID(ctx context.Context, id uuid.UUID) (*types.InsightTopic, error) {
	var model models.InsightTopic
	if err := r.db.WithContext(ctx).First(&model, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, core.ErrNotFound
		}
		return nil, err
	}
	return insightTopicModelToType(&model), nil
}

// FindByOrganizationID retrieves all insight topics for an organization
func (r *InsightTopicRepository) FindByOrganizationID(ctx context.Context, orgID uuid.UUID) ([]types.InsightTopic, error) {
	var topicModels []models.InsightTopic
	if err := r.db.WithContext(ctx).Where("organization_id = ?", orgID).Order("name ASC").Find(&topicModels).Error; err != nil {
		return nil, err
	}

	topics := make([]types.InsightTopic, len(topicModels))
	for i, m := range topicModels {
		topics[i] = *insightTopicModelToType(&m)
	}
	return topics, nil
}

// FindAll retrieves all insight topics
func (r *InsightTopicRepository) FindAll(ctx context.Context) ([]types.InsightTopic, error) {
	var topicModels []models.InsightTopic
	if err := r.db.WithContext(ctx).Order("name ASC").Find(&topicModels).Error; err != nil {
		return nil, err
	}

	topics := make([]types.InsightTopic, len(topicModels))
	for i, m := range topicModels {
		topics[i] = *insightTopicModelToType(&m)
	}
	return topics, nil
}

// SearchSimilar performs vector similarity search for topics
func (r *InsightTopicRepository) SearchSimilar(ctx context.Context, embedding []float32, limit int, threshold float64) ([]types.InsightTopic, []float64, error) {
	var results []struct {
		models.InsightTopic
		Distance float64 `gorm:"column:distance"`
	}

	embeddingVector := pgvector.NewVector(embedding)
	query := fmt.Sprintf(
		`SELECT *, (embedding <=> '%s') as distance FROM insight_topic 
		 WHERE embedding IS NOT NULL AND (embedding <=> '%s') < %f
		 ORDER BY distance ASC LIMIT %d`,
		embeddingVector.String(),
		embeddingVector.String(),
		1-threshold, // Convert similarity threshold to distance
		limit,
	)

	if err := r.db.WithContext(ctx).Raw(query).Scan(&results).Error; err != nil {
		return nil, nil, err
	}

	topics := make([]types.InsightTopic, len(results))
	scores := make([]float64, len(results))
	for i, r := range results {
		topics[i] = *insightTopicModelToType(&r.InsightTopic)
		scores[i] = 1 - r.Distance // Convert distance back to similarity
	}
	return topics, scores, nil
}

// Save creates a new insight topic
func (r *InsightTopicRepository) Save(ctx context.Context, topic *types.InsightTopic) error {
	model := insightTopicTypeToModel(topic)
	if model.ID == uuid.Nil {
		model.ID = uuid.New()
		topic.ID = model.ID
	}
	return r.db.WithContext(ctx).Create(model).Error
}

// Update updates an existing insight topic
func (r *InsightTopicRepository) Update(ctx context.Context, topic *types.InsightTopic) error {
	model := insightTopicTypeToModel(topic)
	return r.db.WithContext(ctx).Save(model).Error
}

// UpdateContentCount updates the content count for a topic
func (r *InsightTopicRepository) UpdateContentCount(ctx context.Context, id uuid.UUID, count int) error {
	return r.db.WithContext(ctx).Model(&models.InsightTopic{}).
		Where("id = ?", id).
		Update("content_count", count).Error
}

// UpdateLastInsightAt updates the last insight timestamp for a topic
func (r *InsightTopicRepository) UpdateLastInsightAt(ctx context.Context, id uuid.UUID, timestamp time.Time) error {
	return r.db.WithContext(ctx).Model(&models.InsightTopic{}).
		Where("id = ?", id).
		Update("last_insight_at", timestamp).Error
}

// Delete removes an insight topic by its ID
func (r *InsightTopicRepository) Delete(ctx context.Context, id uuid.UUID) error {
	result := r.db.WithContext(ctx).Delete(&models.InsightTopic{}, id)
	if result.Error != nil {
		return result.Error
	}
	if result.RowsAffected == 0 {
		return core.ErrNotFound
	}
	return nil
}
